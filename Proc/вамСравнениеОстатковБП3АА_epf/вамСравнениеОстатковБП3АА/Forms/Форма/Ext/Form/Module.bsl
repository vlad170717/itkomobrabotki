

&НаСервере
Процедура ВывестиТаблицуЗначенияВКодеВТаблицуНаФорме(ТабВКоде, ТабРеквизит, ТабНаФорме)
 
    // реквизит ТабРеквизит и соответствующий
    // ему элемент формы ТабНаФорме уже созданы
    // нами в визуальном режиме
 
    // 1. добавляем колонки из ТабВкоде в реквизит ТабРеквизит
 
    НовыеРеквизиты = Новый Массив;
 
    Для Каждого Колонка Из ТабВКоде.Колонки Цикл
         НовыеРеквизиты.Добавить(
            Новый РеквизитФормы(
                Колонка.Имя, Колонка.ТипЗначения,
                ТабРеквизит
            )
         );
    КонецЦикла;
 
    ИзменитьРеквизиты(НовыеРеквизиты);
 
    // 2. добавляем колонки из ТабВКоде в элемент ТабНаФорме
 
    Для Каждого Колонка Из ТабВКоде.Колонки Цикл
 
        НовыйЭлемент = Элементы.Добавить(
            ТабРеквизит + "_" + Колонка.Имя, Тип("ПолеФормы"), Элементы[ТабНаФорме]
        );
        НовыйЭлемент.Вид = ВидПоляФормы.ПолеВвода;
        НовыйЭлемент.ПутьКДанным = ТабРеквизит + "." + Колонка.Имя;
    КонецЦикла;
 
    // 3. наконец, передаём данные из ТабВКоде в ТабРеквизит
 
    ЗначениеВРеквизитФормы(ТабВКоде, ТабРеквизит);
 
    // готово!    
 
КонецПроцедуры

// Преобразовать табличный документ в таблицу значений.
//
// Параметры:
//	ТабДок - <ТабличныйДокумент> - Исходный табличный документ;
//	СтруктураКолонок - <Структура>, <ТаблицаЗначений> - Структура колонок;
//	НачалоСтрока - <Число> - Строка начала области;
//	НачалоСтолбец - <Число> - Столбец начала области;
//	КонецСтрока - <Число> - Строка конца области;
//	КонецСтолбец - <Число> - Столбец конца области.
//	
// Возвращаемое значение:
//	<ТаблицаЗначений> - Полученная таблица значений.
//
Функция ПреобразоватьТДвТЗ(ТабДок, СтруктураКолонок, Знач НачалоСтрока = Неопределено, Знач НачалоСтолбец = Неопределено, Знач КонецСтрока = Неопределено, Знач КонецСтолбец = Неопределено) Экспорт
 
	// Определение габаритов таблицы
	Если НачалоСтрока = Неопределено И НачалоСтолбец = Неопределено Тогда
		НачалоСтрока = 1;
		НачалоСтолбец = 1;
	КонецЕсли;
 
	Если НачалоСтрока = Неопределено Тогда
		НачалоСтрока = 1;
		Пока НЕ ТабДок.Область(НачалоСтрока, НачалоСтолбец).СодержитЗначение 
		 И НачалоСтрока < ТабДок.ВысотаТаблицы 
		Цикл
			НачалоСтрока = НачалоСтрока + 1;
		КонецЦикла;
	ИначеЕсли НачалоСтолбец = Неопределено Тогда
		НачалоСтолбец = 1;
		Пока НЕ ТабДок.Область(НачалоСтрока, НачалоСтолбец).СодержитЗначение 
		 И НачалоСтолбец < ТабДок.ШиринаТаблицы
		Цикл
			НачалоСтолбец = НачалоСтолбец + 1;
		КонецЦикла;
	КонецЕсли;
 
	КонецСтрока = ?(КонецСтрока = Неопределено, ТабДок.ВысотаТаблицы, КонецСтрока);
	КонецСтолбец = ?(КонецСтолбец = Неопределено, ТабДок.ШиринаТаблицы, КонецСтолбец);
 
	// Преобразование
	ЭтоТаблица = (ТипЗнч(СтруктураКолонок) = Тип("ТаблицаЗначений"));
	ТабЗначений = ПолучитьТаблицуВывода(СтруктураКолонок);
 
	Для ИндексСтроки = НачалоСтрока По КонецСтрока Цикл
		СтрокаТЗ = ТабЗначений.Добавить();
 
		ИндексКолонки = НачалоСтолбец;
		Для Каждого Колонка Из СтруктураКолонок Цикл
			НаименованиеКолонки = ?(ЭтоТаблица, Колонка.Наименование, Колонка.Ключ);
			пИндексКолонки = ?(ЭтоТаблица, Колонка.СтолбецОтчёт, ИндексКолонки);
 
			Если ТабДок.Область(ИндексСтроки, пИндексКолонки).СодержитЗначение Тогда
				СтрокаТЗ[НаименованиеКолонки] = ТабДок.Область(ИндексСтроки, пИндексКолонки).Значение;
			Иначе
				СтрокаТЗ[НаименованиеКолонки] = ТабДок.Область(ИндексСтроки, пИндексКолонки).Текст;
			КонецЕсли;
 
			ИндексКолонки = ИндексКолонки + 1;
		КонецЦикла;
	КонецЦикла;
 
	Возврат ТабЗначений;
КонецФункции

// Преобразовать таблицу значений в табличный документ.
//
// Параметры:
//	ТабЗначений - <ТаблицаЗначений> - Исходная таблица значений;
//	ТабДок - <ТабличныйДокумент> - Полученный табличный документ. Если параметр не задан, 
//	 то документ создаётся заново и возвращается функцией;
//	НачалоСтрока - <Число> - Строка начала области;
//	НачалоСтолбец - <Число> - Столбец начала области;
//	ВыводитьЗаголовки - <Булево> - Определяет выводить ли имена колонок или нет.
//	
// Возвращаемое значение:
//	<ТабличныйДокумент> - Полученный табличный документ (возвращает параметр "ТабДок").
//
Функция ПреобразоватьТЗвТД(ТабЗначений, ТабДок = Неопределено, Знач НачалоСтрока = Неопределено, Знач НачалоСтолбец = Неопределено, ВыводитьЗаголовки = Ложь) Экспорт
 
	Если ТабДок = Неопределено Тогда
		ТабДок = Новый ТабличныйДокумент;
	КонецЕсли;
 
	// Определение габаритов таблицы
	НачалоСтрока = ?(НачалоСтрока = Неопределено, 1, НачалоСтрока);
	НачалоСтолбец = ?(НачалоСтолбец = Неопределено, 1, НачалоСтолбец);
 
	// Преобразование
	ИндексСтроки = НачалоСтрока;
	Если ВыводитьЗаголовки Тогда
		ИндексКолонки = НачалоСтолбец;
		Для Каждого Колонка Из ТабЗначений.Колонки Цикл
			ТабДок.Область(ИндексСтроки, ИндексКолонки).Текст = ?(ПустаяСтрока(Колонка.Заголовок), Колонка.Имя, Колонка.Заголовок);
			ИндексКолонки = ИндексКолонки + 1;
		КонецЦикла;
		ИндексСтроки = ИндексСтроки + 1;
	КонецЕсли;
 
	Для Каждого Элемент Из ТабЗначений Цикл
		ИндексКолонки = НачалоСтолбец;
		Для Каждого Колонка Из ТабЗначений.Колонки Цикл
			ТабДок.Область(ИндексСтроки, ИндексКолонки).СодержитЗначение = Истина;
			ТабДок.Область(ИндексСтроки, ИндексКолонки).ТипЗначения = Новый ОписаниеТипов(Колонка.ТипЗначения);
			ТабДок.Область(ИндексСтроки, ИндексКолонки).Значение = Элемент[Колонка.Имя];
			ИндексКолонки = ИндексКолонки + 1;
		КонецЦикла;
		ИндексСтроки = ИндексСтроки + 1;
	КонецЦикла;
 
	Возврат ТабДок;
КонецФункции

// Читает табличный документ из файла MXL и преобразует его в таблицу значений.
//
// Параметры:
//	ИмяФайла - <Строка> - Путь к файлу MXL;
//	СтруктураКолонок - <Структура>, <ТаблицаЗначений> - Структура колонок. Если этот параметр
//		не задан, то структура колонок формируется из самого табличного документа;
//	ЕстьЗаголовок - <Булево> - Есть ли первая строка с заголовками или нет.
//	
// Возвращаемое значение:
//	<ТаблицаЗначений> - Полученная таблица значений.
//
Функция ПрочитатьТЗИзMXL(ИмяФайла, СтруктураКолонок = Неопределено, ЕстьЗаголовок = Истина) Экспорт
 
	ТабДок = Новый ТабличныйДокумент;
	ТабДок.Прочитать(ИмяФайла);
 
	Если СтруктураКолонок = Неопределено И ЕстьЗаголовок Тогда
		СтруктураКолонок = Новый Структура;
		Для ИндексКолонки = 1 По ТабДок.ШиринаТаблицы Цикл
			Обл1 = ТабДок.Область(1, ИндексКолонки);
			Обл2 = ТабДок.Область(2, ИндексКолонки);
			ИмяКолонки = СокрЛП(Обл1.Текст);
			ИмяКолонки = ?(Найти(ИмяКолонки, " ") > 0, СтрЗаменить(ТРег(ИмяКолонки), " ", ""), ИмяКолонки);
			СтруктураКолонок.Вставить(ИмяКолонки, ?(Обл2.СодержитЗначение, Обл2.ТипЗначения, Новый ОписаниеТипов));
		КонецЦикла;
	ИначеЕсли СтруктураКолонок = Неопределено И НЕ ЕстьЗаголовок Тогда
		СтруктураКолонок = Новый Структура;
		Для ИндексКолонки = 1 По ТабДок.ШиринаТаблицы Цикл
			Обл2 = ТабДок.Область(1, ИндексКолонки);
			ИмяКолонки = "К" + Формат(ИндексКолонки, "ЧДЦ=0; ЧН=0; ЧГ=0");
			СтруктураКолонок.Вставить(ИмяКолонки, ?(Обл2.СодержитЗначение, Обл2.ТипЗначения, Новый ОписаниеТипов));
		КонецЦикла;
	КонецЕсли;
 
    Таблица = ПреобразоватьТДвТЗ(ТабДок, СтруктураКолонок, ?(ЕстьЗаголовок, 2, 1), 1);
 
	Возврат Таблица;
КонецФункции

// Сохраняет таблицу значений в файле в виде табличного документа.
//
// Параметры:
//	ИмяФайла - <Строка> - Путь к файлу MXL;
//	ТабЗначений - <ТаблицаЗначений> - Сохраняемая таблица значений;
//	ЕстьЗаголовок - <Булево> - Есть ли первая строка с заголовками или нет.
//
Процедура ЗаписатьТЗВMXL(ИмяФайла, ТабЗначений, ЕстьЗаголовок = Истина) Экспорт
 
	ТабДок = ПреобразоватьТЗвТД(ТабЗначений, Неопределено, 1, 1, ЕстьЗаголовок);
	ТабДок.Записать(ИмяФайла, ТипФайлаТабличногоДокумента.MXL);
 
КонецПроцедуры
//Еще небольшой набор функций для вывода таблицы значений в табличный документ. После формирования табличного документа, - сохраняем его в файл mxl.

//Табличный документ можно сохранить a файлы следующих типов:

//ANSITXT - Текстовый документ
//DOCX - документ MS Word
//HTML
//HTML3
//HTML4
//HTML5
//MXL
//MXL7
//ODS - Файл Open Office
//PDF - файл Acrobat Readr
//TXT - Текстовый документ
//XLS - файл Excel
//XLS95 - файл Excel95
//XLS97 - файл Excel97
//XLSX - файл Excel2010
//Код 1C v 8.3
 // Получаем таблицу значения из файла. 
Функция ЗагрузитьТЗизФайла(ИмяФайла)    
    Путь = КаталогВременныхФайлов() + ИмяФайла; 
    Текст = Новый ЧтениеТекста(Путь, КодировкаТекста.UTF8); 
    стрТЗ = Текст.Прочитать(); 
    Текст.Закрыть(); 
    // получим таблицу значений из строки
    ТЗ = ЗначениеИзСтрокиВнутр(стрТЗ);    
    Возврат ТЗ;    
КонецФункции   

// Заполнить ячейки в строке  значениями 
//
Функция ЗаписьТЗ2ТабДок(записьТЗ,НомерСтроки,ТабличныйДокумент)
    НомерКолонки = 1;
    Символ160 = Символ(160);    
    // цикл по колонкам таблицы
    // РезультатЗапроса.Колонки.Количество()    // - количество колонок
    Для каждого полеТЗ из ЗаписьТЗ цикл 
        // значения ячейки в Excel
        типПоляТЗ = ТипЗнч(полеТЗ);
        если типПоляТЗ = Тип("Число") тогда             
            полеТЗ=Строка(полеТЗ); 
            полеТЗ=СтрЗаменить(полеТЗ,Символ160,"");
            полеТЗ=СтрЗаменить(полеТЗ,",",".");
        иначеесли типПоляТЗ = Тип("Строка") тогда      
        иначе        
            полеТЗ = строка(полеТЗ);
        КонецЕсли;    
        имяОбласти = "R" + номерСтроки + "C" + НомерКолонки;
        имяОбласти = СтрЗаменить(имяОбласти,Символ(160),"");         
        Ячейка = ТабличныйДокумент.Область(имяОбласти);
        Ячейка.Текст = полеТЗ;
        НомерКолонки = НомерКолонки + 1;
    КонецЦикла;            
КонецФункции

// Заполнить наименованиями колонок таблицу
Функция НаимКолонок2Mxl(ТаблицаЗначений,ТабличныйДокумент)
    // массКолонки = новый массив();
    номерСтроки=1;
    номКолонки=1; 
    ТабличныйДокумент = новый ТабличныйДокумент;
    // цикл по коллекции колонок
    Для НомКол=0 по ТаблицаЗначений.Колонки.Количество() - 1 Цикл
        //Сообщить(Колонка.Имя + "(" + Колонка.ТипЗначения + ")" );            
        имяКолонки=ТаблицаЗначений.Колонки[НомКол].Имя;
        //ТабличныйДокумент.Область(
        имяОбласти = "R" + номерСтроки + "C" + номКолонки;
        имяОбласти = СтрЗаменить(имяОбласти,Символ(160),"");         
        Ячейка = ТабличныйДокумент.Область(имяОбласти);
        //значениеЯчейки = СтрЗаменить(имяОбласти,Символ(160),"");         
        Ячейка.Текст = имяКолонки;
        // на основе текущего шрифта сделаем Жирный
        ЖирныйШрифт = ?(ЖирныйШрифт = Неопределено,Новый Шрифт(Ячейка.Шрифт,,,Истина),ЖирныйШрифт);         
        Ячейка.Шрифт = ЖирныйШрифт;
        номКолонки = номКолонки + 1;        
    КонецЦикла;
КонецФункции


// Заполнить построчно табличный документ
Функция Таблица2Mxl(ТаблицаЗначений,ТабличныйДокумент)
    //Выборка = РезультатЗапроса.Выбрать();
    НомСтр=1; // заполняем данными начиная со 2-й строки    
    // цикл по строкам таблицы
    Для каждого записьТЗ из ТаблицаЗначений Цикл
        НомСтр = НомСтр + 1;
        // цикл по колонкам таблицы        
        ЗаписьТЗ2ТабДок(записьТЗ,НомСтр,ТабличныйДокумент);         
    КонецЦикла;    
КонецФункции

// Таблица значений в табличный документ
Функция ТаблицаЗначений2Mxl(ТаблицаЗначений,ФайлMxl)
    ТабличныйДокумент = новый ТабличныйДокумент;
    // вывести колонки
    НаимКолонок2Mxl(ТаблицаЗначений,ТабличныйДокумент);
    // вывести содержимое таблицы    
    Таблица2Mxl(ТаблицаЗначений,ТабличныйДокумент);
    ТабличныйДокумент.Записать(ФайлMxl,ТипФайлаТабличногоДокумента.MXL);
    ТабличныйДокумент.Показать(ФайлMxl,ФайлMxl);
    Возврат 0;
КонецФункции


Функция    Тест_ВыгрузитьТЗвMxl();
    файл_мТЗИсходныеДанные = "мТЗИсходныеДанные.dat";        
    ТЗ = ЗагрузитьТЗизФайла(файл_мТЗИсходныеДанные);    
    ФайлMxl = КаталогВременныхФайлов() + СтрЗаменить(файл_мТЗИсходныеДанные,".dat",".mxl");  
    ТаблицаЗначений2Mxl(ТЗ,ФайлMxl);
КонецФункции

// Создаёт новую таблицу значений с заданными колонками.
//
// Параметры:
//	пКолонки - <Строка>, <Структура>, <Массив>, <СписокЗначений>, <ТаблицаЗначений> - 
//	 Набор колонок для таблицы значений.
//	
// Возвращаемое значение:
//	<ТаблицаЗначений> - Созданная таблица.
//
Функция ПолучитьТаблицуВывода(пКолонки) Экспорт
 
	ТЗ = Новый ТаблицаЗначений;
 
	Если пКолонки <> Неопределено Тогда 
 
		Если ТипЗнч(пКолонки) = Тип("Строка") Тогда
			пКолонки = РазобратьСтрокуВМассивПоРазделителю(пКолонки);
		КонецЕсли;
 
		Если ТипЗнч(пКолонки) = Тип("Структура") Тогда
			Для Каждого Поле Из пКолонки Цикл	
				СтрокаТабл = ТЗ.Колонки.Добавить(Поле.Ключ, Поле.Значение);	
			КонецЦикла;
		ИначеЕсли ТипЗнч(пКолонки) = Тип("СписокЗначений") Тогда
			Для Каждого Поле Из пКолонки Цикл	
				Если Поле.Пометка Тогда
					СтрокаТабл = ТЗ.Колонки.Добавить(Поле.Значение, пКолонки.ТипЗначения, Поле.Представление);
				КонецЕсли;
			КонецЦикла;
		ИначеЕсли ТипЗнч(пКолонки) = Тип("ТаблицаЗначений") Тогда
			ЕстьНаименование = (пКолонки.Колонки.Найти("Наименование") <> Неопределено);
			ЕстьТипЗначения = (пКолонки.Колонки.Найти("ТипЗначения") <> Неопределено);
			ЕстьЗаголовок = (пКолонки.Колонки.Найти("Заголовок") <> Неопределено);
			ЕстьШирина = (пКолонки.Колонки.Найти("Ширина") <> Неопределено);
			Для Каждого Поле Из пКолонки Цикл
				СтрокаТабл = ТЗ.Колонки.Добавить(?(ЕстьНаименование, Поле.Наименование, ""), ?(ЕстьТипЗначения, Поле.ТипЗначения, Новый ОписаниеТипов), ?(ЕстьЗаголовок, Поле.Заголовок, ""), ?(ЕстьШирина, Поле.Ширина, 0));	
			КонецЦикла;
		Иначе
			Для Каждого Поле Из пКолонки Цикл	
				СтрокаТабл = ТЗ.Колонки.Добавить(Поле);	
			КонецЦикла;
		КонецЕсли;
 
	КонецЕсли;
 
	Возврат ТЗ;	
КонецФункции

// Разбирает строку в массив подстрок по разделителю. 
// При этом пробелы между подстроками не учитываются.
//
// Параметры:
//	Стр - исходная строка;
//	СтрРазделитель - разделитель, по умолчанию ",";
//	ИгнорироватьПустые - игнорировать ли пустые места между разделителями.
//
// Возвращаемое значение:
//	Массив строк
//
Функция РазобратьСтрокуВМассивПоРазделителю(Знач Стр, СтрРазделитель = ",", ИгнорироватьПустые = Ложь) Экспорт
 
	Результат = Новый Массив;
 
	ВхождениеРазделителя = Найти(Стр, СтрРазделитель);
	Пока ВхождениеРазделителя <> 0 Цикл
		ЧастьДоРазделителя = СокрЛП(Лев(Стр, ВхождениеРазделителя - 1));
		Если НЕ (ИгнорироватьПустые И ПустаяСтрока(ЧастьДоРазделителя)) Тогда
			Результат.Добавить(ЧастьДоРазделителя);
		КонецЕсли;
		Стр = СокрЛП(Сред(Стр, ВхождениеРазделителя + 1));
		ВхождениеРазделителя = Найти(Стр, СтрРазделитель);
	КонецЦикла;
 
	Если НЕ (ИгнорироватьПустые И ПустаяСтрока(Стр)) Тогда
		Результат.Добавить(СокрЛП(Стр));
	КонецЕсли;
 
	Возврат Результат;	
КонецФункции

&НаСервере
Процедура СравнитьНаСервере()
	
	ТЗАА = 	ПрочитатьТЗИзMXL(ИмяФайла);	
	
	КвалификаторыСтроки = Новый КвалификаторыСтроки(11);
    ОписаниеСтроки = Новый ОписаниеТипов("Строка", ,КвалификаторыСтроки);	
	
	ТЗАА.Колонки.Добавить("Код", ОписаниеСтроки);
	
	Для каждого СтрАА Из ТЗАА Цикл
		Код = Лев(СтрАА.НоменклатураКод,2)+"000"+Прав(СтрАА.НоменклатураКод,6);
		СтрАА.Код = Код;
	КонецЦикла; 
	
	ТЗАА.Колонки.Удалить("НоменклатураКод");
	
	Запрос = Новый Запрос;
    Запрос.Текст = 
        "ВЫБРАТЬ
        |	ХозрасчетныйОстатки.Счет КАК Счет,
        |	ХозрасчетныйОстатки.Субконто1.Код КАК Код,
        |	ХозрасчетныйОстатки.Субконто1.Наименование КАК Наименование,
        |	ХозрасчетныйОстатки.КоличествоОстатокДт КАК Количество
        |ИЗ
        |	РегистрБухгалтерии.Хозрасчетный.Остатки(&Период, Счет В ИЕРАРХИИ (&ВыбСчет), &ВидыСубконто, ) КАК ХозрасчетныйОстатки";
 
    Запрос.УстановитьПараметр("Период", КонецДня(Дата) );
    Запрос.УстановитьПараметр("ВыбСчет", ПланыСчетов.Хозрасчетный.НайтиПоКоду("41") );
 
    ВидыСубконто = Новый Массив;
    ВидыСубконто.Добавить(
        ПланыВидовХарактеристик.ВидыСубконтоХозрасчетные.Номенклатура
    );
    Запрос.УстановитьПараметр("ВидыСубконто", ВидыСубконто);
 
    Результат = Запрос.Выполнить();
 
    ТЗБП = Результат.Выгрузить();
 
 //   Пока Записи.Следующий() Цикл
 //
 //       Сообщить(
 //           Записи.Товар.Код +
 //           " Количество [" + Записи.КоличествоОстатокДт + " шт.]" //+
 //           //" Сумма [" + Записи.СуммаОстатокДт + " руб.]"
 //       );
 //
 //   КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	               |	ТЗОстаткиБП.Код КАК Код,
	               |	ТЗОстаткиБП.Количество КАК Количество,
	               |	ТЗОстаткиБП.Наименование КАК Наименование
	               |ПОМЕСТИТЬ ОстаткиБП
	               |ИЗ
	               |	&ТЗОстаткиБП КАК ТЗОстаткиБП
	               |;
	               |
	               |////////////////////////////////////////////////////////////////////////////////
	               |ВЫБРАТЬ
	               |	ТЗОстаткиАА.Код КАК Код,
	               |	ТЗОстаткиАА.КоличествоОстаток КАК Количество,
	               |	ТЗОстаткиАА.НоменклатураНаименование КАК Наименование
	               |ПОМЕСТИТЬ ОстаткиАА
	               |ИЗ
	               |	&ТЗОстаткиАА КАК ТЗОстаткиАА
	               |;
	               |
	               |////////////////////////////////////////////////////////////////////////////////
	               |ВЫБРАТЬ
	               |	ЕСТЬNULL(ОстаткиАА.Код, ОстаткиБП.Код) КАК Код,
	               |	ЕСТЬNULL(ОстаткиАА.Наименование, ОстаткиБП.Наименование) КАК Наименование,
	               |	ОстаткиАА.Количество КАК КоличествоАА,
	               |	ОстаткиБП.Количество КАК КоличествоБП,
	               |	ОстаткиБП.Количество - ОстаткиАА.Количество КАК Разница
	               |ИЗ
	               |	ОстаткиБП КАК ОстаткиБП
	               |		ПОЛНОЕ СОЕДИНЕНИЕ ОстаткиАА КАК ОстаткиАА
	               |		ПО ОстаткиБП.Код = ОстаткиАА.Код
	               |
	               |УПОРЯДОЧИТЬ ПО
	               |	Разница УБЫВ";
	Запрос.УстановитьПараметр("ТЗОстаткиАА", ТЗАА);
	Запрос.УстановитьПараметр("ТЗОстаткиБП", ТЗБП);
	
    Результат = Запрос.Выполнить();
 
    ТЗРезультат = Результат.Выгрузить();
	
	ВывестиТаблицуЗначенияВКодеВТаблицуНаФорме(ТЗРезультат, "ТЗКод", "ТЗФорма");
	
КонецПроцедуры

&НаКлиенте
Процедура Сравнить(Команда)
	СравнитьНаСервере();
КонецПроцедуры


&НаКлиенте
Процедура ВыборФайла(Элемент, ОбъектХранения, ИмяСвойства, ПроверятьСуществование, Знач РасширениеПоУмолчанию = "mxl",
	АрхивироватьФайлДанных = Истина, ВыборФайлаПравил = Ложь)
	
	ДиалогВыбораФайла = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Открытие);

	ДиалогВыбораФайла.Фильтр = "Файл данных (*.mxl)|*.mxl";
	ДиалогВыбораФайла.Расширение = "mxl";
	
	
	ДиалогВыбораФайла.Заголовок = НСтр("ru = 'Выберите файл'");
	ДиалогВыбораФайла.ПредварительныйПросмотр = Ложь;
	ДиалогВыбораФайла.ИндексФильтра = 0;
	ДиалогВыбораФайла.ПолноеИмяФайла = Элемент.ТекстРедактирования;
	ДиалогВыбораФайла.ПроверятьСуществованиеФайла = ПроверятьСуществование;
	
	ДополнительныеПараметры = Новый Структура;
	ДополнительныеПараметры.Вставить("ОбъектХранения", ОбъектХранения);
	ДополнительныеПараметры.Вставить("ИмяСвойства",    ИмяСвойства);
	ДополнительныеПараметры.Вставить("Элемент",        Элемент);
	
	Оповещение = Новый ОписаниеОповещения("ДиалогВыбораФайлаОбработкаВыбора", ЭтотОбъект, ДополнительныеПараметры);
	ДиалогВыбораФайла.Показать(Оповещение);
	
КонецПроцедуры

&НаКлиенте
Процедура ДиалогВыбораФайлаОбработкаВыбора(ВыбранныеФайлы, ДополнительныеПараметры) Экспорт
	
	Если ВыбранныеФайлы = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ДополнительныеПараметры.ОбъектХранения[ДополнительныеПараметры.ИмяСвойства] = ВыбранныеФайлы[0];
	
	Элемент = ДополнительныеПараметры.Элемент;
	
	ИмяФайлаПриИзменении(ИмяФайла);
	
КонецПроцедуры

&НаКлиенте
Процедура ИмяФайлаПриИзменении(Элемент)
	СохранитьНастройки();
КонецПроцедуры

&НаСервере
Процедура СохранитьНастройки()
	ХранилищеОбщихНастроек.Сохранить("вамСравнениеОстатковБПАА", "ИмяФайла", ИмяФайла);
КонецПроцедуры


&НаКлиенте
Процедура ИмяФайлаНачалоВыбора(Элемент, ДанныеВыбора, СтандартнаяОбработка)
	ВыборФайла(Элемент, ЭтотОбъект, "ИмяФайла", Истина)
КонецПроцедуры


&НаСервере
Процедура ПриОткрытииНаСервере()
		ИмяФайла = 	ХранилищеОбщихНастроек.Загрузить("вамСравнениеОстатковБПАА", "ИмяФайла");
КонецПроцедуры

&НаКлиенте
Процедура ПриОткрытии(Отказ)
	ПриОткрытииНаСервере();
КонецПроцедуры



